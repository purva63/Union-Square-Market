from ast import arg
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
from multiprocessing import Pool, Process
from platform import node
import subprocess
import sys
import threading
import time
import Pyro4
from datetime import datetime
import uuid


@Pyro4.expose
class SellerClass(object):
    #For the seller class, the items to sell, it's neighbors, the initial item to sell, its id and the threadpool for executing
    #lookups and replies
    def __init__(self, node_id, item_count, neighbors, itemToSell):
        self.item_count = item_count
        self.neighbors = neighbors
        self.itemToSell = itemToSell
        self.node_id = node_id
        self.max_item_count = item_count
        self.executor = ThreadPoolExecutor(max_workers=15)
    """
    The exposed method lookup for each seller is called by its peers 
    The method replies back to the peer if the item on lookup message is what it is selling
    The method defaults to and always sends the request forward so other sellers can be notified aswell
    The method does not return anything
    A lookup consists of a uid - A unique id generated by a buyer for a transaction for an item
    lst is a stack to backtrack on reply for the sellers, hopcount and itemToBuy are set globally and the buyer respectively
    """
    def lookup(self,uid,hop_count,lst,itemToBuy):
        try:
            
            logging.basicConfig(filename='example_buyer.log',level=logging.DEBUG)
            logging.info(str(uid)+" :Item to buy:"+ str(itemToBuy) +" Sell:"+str(self.itemToSell) + " hop count:"+ str(hop_count))
            #match found on lookup and current item
            if itemToBuy == self.itemToSell:
                new_lst = lst.copy()
                #process_result.append(True)
                self.reply(uid, self.node_id, new_lst)
            #default to flooding lookups when hop_count is not terminal
            if hop_count > 0:
                for neighbor in self.neighbors:
                    #do not send lookup back to parent lookup
                    if lst!=[] and lst[-1]!=neighbor:
                        with Pyro4.Proxy("PYRONAME:"+neighbor) as peer:
                            new_lst = lst.copy()
                            #Add current peer to lookup stack
                            new_lst.append("Peer"+str(self.node_id))
                            timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                            logging.info(timestamp+" -"+str(uid)+" Lookup for "+ str(itemToBuy)+" sending from Peer"+str(self.node_id)+" to "+ neighbor + ":"+ str(new_lst))
                            #lookup sent to neighbors in threaded fashion concurrently
                            future = self.executor.submit(peer.lookup,uid,hop_count-1, new_lst, itemToBuy)
                            
                    elif lst == []:
                        logging.info(str(uid)+" :lst is empty in Seller")
                    else:
                       
                        logging.info(str(uid)+" :lst top is parent in seller"+" :"+str(lst)+":"+ str(neighbor))
            else:
                logging.info(str(uid)+" :"+str(self.node_id)+" has hop count"+ str(hop_count))
        except Exception as e:
            logging.info(str(uid)+' :Seller '+ str(self.node_id)  +'flood Unable to get the result :'+str(lst)+":"+str(e))   
 
    """
    The reply method is triggered by a lookup only at the seller
    This method consists of the unique transaction id for the buyer for a request so buyer can initiate final transaction
    The sellerid is used by the buyer to find the peer directly from naming register
    The list is used to backtrack to the original buyer who flooeded to the seller
    """
    def reply(self, uid, sellerid, lst):
        try:
            logging.basicConfig(filename='example_buyer.log',level=logging.DEBUG)
            if lst!=[]:
                #top of stack has the immediate peer address
                to_send = lst.pop()
                with Pyro4.Proxy("PYRONAME:"+to_send) as peer:
                    new_lst = lst.copy()
                    timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                    logging.info(timestamp+" -"+str(uid)+" Reply sending from: Peer"+str(self.node_id) + "to "+to_send+":"+str(new_lst))
                    #threaded reply since multiple replies can be called, for example by the lookup itself or another backtrack reply
                    future = self.executor.submit(peer.reply,uid,sellerid, new_lst)
            else:
                logging.info(+str(uid)+" List is empty. Peer"+str(self.node_id))  
                return
        except Exception as e:
            logging.info(str(uid)+' :Seller '+ str(self.node_id)  +'unable to reply :'+str(lst)+":"+str(e)) 
    """
    This is the transaction method used by buyer directly
    This method receives transaction from buyerId while itemToBuy is matched once again to see if 
    the selling item has changed or not
    """
    def contactSeller(self,buyerId,sellerId,itemToBuy, uid):
        logging.basicConfig(filename='example_buyer.log',level=logging.DEBUG)
        if itemToBuy!= self.itemToSell or self.item_count == 0:
            return False
        #lock acquired
        lock = threading.Lock()
        with lock:
            #decrement the count and returns true for successful transaction to the buyer
            self.item_count = self.item_count - 1
            timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            logging.info(timestamp+" -"+str(uid)+" Item reduced at: Peer"+str(self.node_id) +"to: "+str(self.item_count) 
            + ". Reply to be sent to:"+ str(buyerId))
            #change item to sell to the next item when out of items. This is done inside the lock 
            #hence other requests for same object in the queue fail to match the item
            if(self.item_count==0):
                rev_dict = {"fish":0,"boar":1,"salt":2}
                dict = {0:"fish",1:"boar",2:"salt"}
                curr_item = rev_dict[self.itemToSell]
                self.itemToSell = dict[(curr_item+1)%3]
                self.item_count = self.max_item_count
                logging.info("Seller Peer" + str(self.node_id) +"will now sell" + self.itemToSell)
            return True
    """
    The register peer method starts threads to listen for requests on the exposed object. 
    It registers itself with the node id at the naming register and requestLoop runs infinitely listening
    to requests
    """
    def registerPeer(self):
        try:
            logging.basicConfig(filename='example_buyer.log',level=logging.DEBUG)
            with Pyro4.Daemon(host="127.0.0.1", port=(5000+self.node_id)) as daemon:
                ns = Pyro4.locateNS()
                uri = daemon.register(self)
                ns.register("Peer"+str(self.node_id), uri)
                timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                logging.info(timestamp+"Peer"+str(self.node_id)+" uri="+ str(uri))
                #Listening
                future = self.executor.submit(daemon.requestLoop)
                future.result()
        except Exception as e:
            logging.info('Seller Unable to get the result:'+ str(e))

if __name__ == '__main__':
    #logging.basicConfig(filename='outer.log', level=logging.DEBUG)
    total_nodes = int(sys.argv[1])
    node_id = int(sys.argv[2])
    item_count = int(sys.argv[3])

    #logging.info(type(node_id))
    if total_nodes == 2:
        neighbors = [sys.argv[4]]
        item_to_sell = sys.argv[5]
    else:
        neighbors = [sys.argv[4],sys.argv[5]]
        item_to_sell = sys.argv[6]
    sellerClass = SellerClass(node_id, item_count, neighbors, item_to_sell)
    #Expose object
    sellerClass.registerPeer()